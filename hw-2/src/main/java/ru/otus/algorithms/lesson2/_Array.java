package ru.otus.algorithms.lesson2;

public interface _Array<T> {
    /**
     * Получить элемент по индексу
     * @return - элемент, который по этому индексу, либо null
     * @throws ArrayIndexOutOfBoundsException - если index выходит за пределы массива
     */
    T get(int index);

    /**
     * Добавить элемент по указанному индексу.
     * Если index выходит за пределы массива - массив расширяем массив добавлением такого кол-ва ячеек,
     * чтобы этот индекс стал доступен.
     * Добавленные ячейки - считаем заполненными (значением по-умолчанию = null).
     * @throws ArrayIndexOutOfBoundsException - если index < 0
     */
    void add(int index, T element);

    /**
     * Добавить элемент в конец массива
     * Метод добавлен с целью usability
     */
    void add(T element);

    /**
     * Устанавливает элемент массива по указанному индексу.
     * Только для тех индексов, которые в пределах массива
     * @throws ArrayIndexOutOfBoundsException - если index выходит за пределы массива
     */
    void set(int index, T element);

    /**
     * Удаляем элемент из массива.
     * Особый контракт метода!!!
     * Если удаляем последний элемент - size массива уменьшается на 1.
     * Если удаляем любой элемент кроме последнего - значение соотв.ячейки выставляем в null, size сохраняется.
     * Особенность контракта в том, что из-за такой постановки - появляется гистерезис.
     * То есть, возможна ситуация, когда size зависит от очередности, с которой вызывали remove для 2-х значений index
     * @throws ArrayIndexOutOfBoundsException - если index вызодит за пределы массива
     */
    void remove(int index);

    /**
     * Сколько элементов помещено в массив
     * Это значение связано с индексом последнего элемента в массиве
     */
    int size();

    /**
     * Актуальный размер массива - то есть, сколько элементов выделено.
     * Пределы массива - считаются от 0 до capacity-1
     */
    int capacity();
}
