<input> 5 2 1 3 5 4
; считываем количество
read 0
add =10; это значение - смещение, сколько регистров пропустить, перед тем, как использовать регистры для записи данных с input-ленты
store 1 ; конец массива
; инициализируем счетчик
load =10
store 2 ; счетчик
; считываем данные
getdata:
read *2
load 2
add =1
store 2
sub 1
jz stop
jgtz stop
jmp getdata
stop:
; пишем код тут; алгоритм: i от 0 до N-1, k от i+1 до N
; используем значения:
;   =10 -> смещение по регистрам. То есть, j-й элемент массива храним в регистре j+смещение
;   R_1 -> N + смещение(N = кол-во элементов массива). То есть, номер регистра, в котором последний элемент массива
;   R_2 -> i + смещение
;   R_3 -> k + смщение
;   R_4 -> tmp значение (используем для перестановки элементов массива)
;   R_5 -> N-1 + смещение. Оптимизируем кол-во процессорных тактов за счет памяти. Т.к. в коде, будут такие команды внутри цикла: "sub 1; add =1" - заменяем на "sub 5"
;   R_6 -> N-2 + смещение. Оптимизируем кол-во процессорных тактов за счет памяти. Т.к. в коде, будут такие команды внутри цикла: "sub 1; add =2" - заменяем на "sub 6"
load 1
sub =1
store 5
sub =1
store 6
; алгоритм
;   пробегаем R_2 от ${смещение} до R_1 - 1
;   пробегаем R_3 от R_2 + 1 до R_1
;   сравниваем *R_2 и *R_3, и если требуется - меняем местами, используем R_4 для tmp
load =10
store 2 ; счетчик i
add =1
store 3 ; счетчик k
compare:
load *3 ; в начале должен быть тот элемент, который меньше
sub *2
jgtz next_k ; если R_k - R_i > 0 - тогда местами менять не надо
; это блок switch_i_k: , но, т.к. на него нет jz,jgtz - вносим под комментарий
load *2
store 4
load *3
store *2
load 4
store *3
next_k:
load 3
sub 5 ; если k можно увеличивать (не дошел до края) - увеличиваем на 1, иначе - переходим к next_i
jz next_i
load 3
add =1
store 3
jmp compare
next_i:
load 2
sub 6 ; если i можно увеличивать (не дошел до края) - увеличиваем на 1, иначе - переходим к outdata
jz prepare_outdata
load 2
add =1 ; новое значение для i
store 2
add =1 ; новое - стартовое значение для k
store 3 ; 
jmp compare
prepare_outdata:
load =10
store 2
; выводим данные
outdata:
write *2
load 2
add =1
store 2
sub 1
jz exit
jgtz exit
jmp outdata
exit:
halt